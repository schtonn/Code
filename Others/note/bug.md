```cpp
时间限制：1.0s   内存限制：256.0MB   代码提交间隔：5分钟(现在可以提交)  
试题来源：NOIP2004 提高组 第一天第四题
问题描述
　　所谓虫食算，就是原先的算式中有一部分被虫子啃掉了，需要我们根据剩下的数字来判定被啃掉的字母。来看一个简单的例子：

　　.

　　其中#号代表被虫子啃掉的数字。根据算式，我们很容易判断：第一行的两个数字分别是5和3，第二行的数字是5。
　　现在，我们对问题做两个限制：
　　首先，我们只考虑加法的虫食算。这里的加法是N进制加法，算式中三个数都有N位，允许有前导的0。
　　其次，虫子把所有的数都啃光了，我们只知道哪些数字是相同的，我们将相同的数字用相同的字母表示，不同的数字用不同的字母表示。如果这个算式是N进制的，我们就取英文字母表午的前N个大写字母来表示这个算式中的0到N-1这N个不同的数字：但是这N个字母并不一定顺序地代表0到N-1)。输入数据保证N个字母分别至少出现一次。
　　.

　　上面的算式是一个4进制的算式。很显然，我们只要让ABCD分别代表0123，便可以让这个式子成立了。你的任务是，对于给定的N进制加法算式，求出N个不同的字母分别代表的数字，使得该加法算式成立。输入数据保证有且仅有一组解。
输入格式
　　输入包含4行。第一行有一个正整数N(N<=26)，后面的3行每行有一个由大写字母组成的字符串，分别代表两个加数以及和。这3个字符串左右两端都没有空格，从高位到低位，并且恰好有N位。
输出格式
　　输出一行。在这一行中，应当包含唯一的那组解。解是这样表示的：输出N个数字，分别表示A，B，C……所代表的数字，相邻的两个数字用一个空格隔开，不能有多余的空格。
样例输入
5
ABCED
BDACE
EBBAA
样例输出
1 0 3 4 2
数据规模和约定
　　对于30％的数据，保证有N<＝10；
　　对于50％的数据，保证有N<＝15；
　　对于全部的数据，保证有N<＝26。




#include "bits/stdc++.h"
using namespace std;
char a[30],b[30],c[30];
int ans[300],used[30],p[30],u[30],tot;
int n;
bool check(){
	for(int i=n;i>=1;i--){
		if(ans[a[i]]==-1||ans[b[i]]==-1||ans[c[i]]==-1)continue;
		if((ans[a[i]]+ans[b[i]])%n!=ans[c[i]]){
			if((ans[a[i]]+ans[b[i]]+1)%n!=ans[c[i]])return 0;
		}
	}
	return 1;
}
void print(){
	int flag=0;
	for(int i=n;i>=1;i--){
		int s=ans[a[i]]+ans[b[i]]+flag;
		if(ans[c[i]]!=s%n)return ;
		flag=s/n;
	}
	cout<<ans['A'];
	for(int i='A'+1;i<='A'+n-1;i++)cout<<' '<<ans[i];
	exit(0);
}
void dfs(int now){
	if(now>n){
		print();
		return;
	}
	for(int i=n-1;i>=0;i--){
		if(used[i])continue;
		ans[p[now]+'A'-1]=i;
		if(check()){
			used[i]=1;
			dfs(now+1);
			used[i]=0;
		}
	}
	ans[p[now]+'A'-1]=-1;
}
int main(){
	memset(ans,-1,sizeof(ans));
	cin>>n;
	scanf("%s%s%s",a+1,b+1,c+1);
	for(int i=n;i>=1;i--){
		if(!u[a[i]-'A'+1])p[++tot]=a[i]-'A'+1,u[a[i]-'A'+1]=1;
		if(!u[b[i]-'A'+1])p[++tot]=b[i]-'A'+1,u[b[i]-'A'+1]=1;
		if(!u[c[i]-'A'+1])p[++tot]=c[i]-'A'+1,u[c[i]-'A'+1]=1;
	}
	dfs(1);
	return 0;
}
```